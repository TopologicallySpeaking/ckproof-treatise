On the last page, we saw how ckproof can automatically perform some parts of our
proofs for us. On this page, we will build up enough machinery to allow ckproof
to do all classical propositional calculus automatically. This will allow us to
finally move on to more interesting things.

# Conjunctive Normal Form

The technique used for the purpose of automatically proving statements in
<ref ClassicalLogic /> makes heavy use of Conjunctive Normal Form (CNF). This is
a kind of propositional statement which is formed by the following process:

<ol>
  <li>
    Take a bunch of variables. These variables, along with their negations, are
    called ``literals".
  </li>
  <li>
    Combine the some of the literals, whichever ones you wish, into a bunch of
    groups using <ref ClassicalLogic.or />. These combinations are called
    ``terms".
  </li>
  <li>
    Combine all of the terms which you've created using
    <ref ClassicalLogic.and />. The resulting statement is now in CNF.
  </li>
</ol>

In <ref ClassicalLogic />, all statements are equivalent to some other statement
written in CNF. For example,

\[
  !('phi & ('psi -> 'chi))
\]

is equivalent to

\[
  (!'phi | 'psi) & (!'phi | !'chi)
\].

You can see that this statement is in CNF by breaking it up into its component
parts. The statement is formed from two terms: \(!'phi | 'psi\) and \(!'phi |
!'chi\) which are combined by a <ref ClassicalLogic.and />. Furthermore, both of
the terms are formed using <ref ClassicalLogic.or /> on the variables \('phi\),
\('psi\), \('chi\) and their negations.

As a counterexample, the statement

\[
  !('phi & 'psi)
\]

is <em>not</em> written in CNF because you are only allowed use negation on
variables.

This form has some nice properties which ckproof takes advantage of. The first
thing we need to do is prove some theorems which allow ckproof to convert a
statement into its equivalent CNF.

## CNF for The Operators of Classical Logic

Each of the operators in <ref ClassicalLogic /> have a canonical CNF. Most
trivially, \(!'phi\), \('phi | 'psi\), and \('phi & 'psi\) are already in CNF.
For the other operators, we must be a little more clever. We'll start with a
lemma which is used in the proofs which follow.

\Lemma DNegEquiv: ClassicalLogic {
  name = "Double Negative Equivalence"
  tagline = {
    Statements are equivalent to their double negatives.
  }
  description = {
    This lemma is nothing more than a combination of
    <ref ClassicalLogic.DNegElim /> and <ref ClassicalLogic.DNegIntro />. It's
    worth proving simply because this combined form can save a few steps in
    certain proofs.
  }

  var phi: Prop

  assertion = !!'phi <-> 'phi;
}

\Proof DNegEquiv: ClassicalLogic {
  The proof is trivial.

  |DNegElim| !!'phi -> 'phi;
  |DNegIntro| 'phi -> !!'phi;
  |EquivIntroInf| !!'phi <-> 'phi;
}

Using this lemma, we derive the CNF for <ref ClassicalLogic.implies /> and
<ref ClassicalLogic.equiv />.

\Theorem ImpliesCNF: ClassicalLogic {
  name = "Conjunctive Normal Form of Material Implication"
  tagline = {
    The canonical Conjunctive Normal Form of <ref ClassicalLogic.implies /> is
    \(!'phi | 'psi\).
  }

  var phi: Prop
  var psi: Prop

  assertion = ('phi -> 'psi) <-> (!'phi | 'psi);
}

\Proof ImpliesCNF: ClassicalLogic {
  This is derived from <ref ClassicalLogic.DNegEquiv />.

  |DNegEquiv| !!'phi <-> 'phi;
  |EquivSymmetric| 'phi <-> !!'phi;

  We then apply <ref ClassicalLogic.implies /> to both sides of the equivalence.

  |!sub| ('phi -> 'psi) <-> (!!'phi -> 'psi);

  By definition, this is what we were trying to show.

  |!def| ('phi -> 'psi) <-> (!'phi | 'psi);
}

\Theorem EquivCNF: ClassicalLogic {
  name = "Conjunctive Normal Form of Material Equivalence"
  tagline = {
    The canonical Conjunctive Normal Form of <ref ClassicalLogic.equiv /> is
    \((!'phi | 'psi) & ('psi | 'phi)\).
  }

  var phi: Prop
  var psi: Prop

  assertion = ('phi <-> 'psi) <-> (!'phi | 'psi) & (!'psi | 'phi);
}

\Proof EquivCNF: ClassicalLogic {
  This is derived from the Conjunctive Normal Form for both the forward and
  backward implications of \('phi <-> 'psi\).

  |ImpliesCNF| ('phi -> 'psi) <-> (!'phi | 'psi);
  |ImpliesCNF| ('psi -> 'phi) <-> (!'psi | 'phi);

  Because <ref ClassicalLogic.and /> is a function over
  <ref ClassicalLogic.equiv />, we can conclude

  |AndFunctionEquiv|
    ('phi -> 'psi) & ('psi -> 'phi) <-> (!'phi | 'psi) & (!'psi | 'phi);.

  By definition, this is what were trying to show.

  |!def| ('phi <-> 'psi) <-> (!'phi | 'psi) & (!'psi | 'phi);
}

## Constructing CNF for Larger Statements

\Theorem DeMorganAnd: ClassicalLogic {
  name = "De Morgan's Law for Logical Conjunction"
  tagline = {
    TODO: Tagline.
  }

  var phi: Prop
  var psi: Prop

  assertion = !('phi & 'psi) <-> (!'phi | !'psi);
}

\Proof DeMorganAnd: ClassicalLogic {
  |DNegEquiv| !!('phi -> !'psi) <-> ('phi -> !'psi);
  |!def| !('phi & 'psi) <-> ('phi -> !'psi);

  |ImpliesCNF| ('phi -> !'psi) <-> (!'phi | !'psi);
  |EquivTransitive| !('phi & 'psi) <-> (!'phi | !'psi);
}

\Theorem DeMorganOr: ClassicalLogic {
  name = "De Morgan's Law for Logical Disjunction"
  tagline = {
    TODO: Name.
  }

  var phi: Prop
  var psi: Prop

  assertion = !('phi | 'psi) <-> (!'phi & !'psi);
}

\Proof DeMorganOr: ClassicalLogic {
  |EquivReflexive| !(!'phi -> 'psi) <-> !(!'phi -> 'psi);
  |!def| !('phi | 'psi) <-> !(!'phi -> 'psi);

  |DNegEquiv| !!'psi <-> 'psi;
  |EquivSymmetric| 'psi <-> !!'psi;
  |!sub| !(!'phi -> 'psi) <-> !(!'phi -> !!'psi);
  |EquivTransitive| !('phi | 'psi) <-> !(!'phi -> !!'psi);

  |!def| !('phi | 'psi) <-> (!'phi & !'psi);
}

\Theorem ImpliesDistribAnd: ClassicalLogic {
  name = "Material Implication Distributes Over Logical Conjunction"
  tagline = {
    TODO: Tagline.
  }

  var phi: Prop
  var psi: Prop
  var chi: Prop

  assertion = ('phi -> ('psi & 'chi)) <-> ('phi -> 'psi) & ('phi -> 'chi);
}

\Proof ImpliesDistribAnd: ClassicalLogic {
  |AndRightElim| ('psi & 'chi) -> 'psi;
  |PropSimpleInf| 'phi -> (('psi & 'chi) -> 'psi);
  |PropDistribInf| ('phi -> ('psi & 'chi)) -> ('phi -> 'psi);

  |AndLeftElim| ('psi & 'chi) -> 'chi;
  |PropSimpleInf| 'phi -> (('psi & 'chi) -> 'chi);
  |PropDistribInf| ('phi -> ('psi & 'chi)) -> ('phi -> 'chi);

  |JoinConsequentInf|
    ('phi -> ('psi & 'chi)) -> (('phi -> 'psi) & ('phi -> 'chi));

  |JoinConsequent|
    ('phi -> 'psi) -> (('phi -> 'chi) -> ('phi -> ('psi & 'chi)));
  |PropImport| (('phi -> 'psi) & ('phi -> 'chi)) -> ('phi -> ('psi & 'chi));

  |EquivIntroInf|
    ('phi -> ('psi & 'chi)) <-> ('phi -> 'psi) & ('phi -> 'chi);
}

\Theorem OrDistribAnd: ClassicalLogic {
  name = "Logical Disjunction Distributes Over Logical Conjunction"
  tagline = {
    TODO: Tagline.
  }

  var phi: Prop
  var psi: Prop
  var chi: Prop

  assertion = 'phi | ('psi & 'chi) <-> ('phi | 'psi) & ('phi | 'chi);
}

\Proof OrDistribAnd: ClassicalLogic {
  |ImpliesDistribAnd|
    (!'phi -> ('psi & 'chi)) <-> ((!'phi -> 'psi) & (!'phi -> 'chi));

  |!def| 'phi | ('psi & 'chi) <-> (('phi | 'psi) & ('phi | 'chi));
}

\Theorem AndDistribOr: ClassicalLogic {
  name = "Logical Conjunction Distributes over Logical Disjunction"
  tagline = {
    TODO: Tagline.
  }

  var phi: Prop
  var psi: Prop
  var chi: Prop

  assertion = 'phi & ('psi | 'chi) <-> ('phi & 'psi) | ('phi & 'chi);
}

\Proof AndDistribOr: ClassicalLogic {
  The forward implication is derived from these two theorems.

  |OrRightIntro, #right1| ('phi & 'psi) -> ('phi & 'psi) | ('phi & 'chi);
  |OrLeftIntro, #left1| ('phi & 'chi) -> ('phi & 'psi) | ('phi & 'chi);

  We can rearrange <ref #right1 /> to get

  |PropExport| 'phi -> ('psi -> ('phi & 'psi) | ('phi & 'chi));
  |PropCommutation, #right2| 'psi -> ('phi -> ('phi & 'psi) | ('phi & 'chi));.

  Similarly, for <ref #left1 />, we get

  |PropExport| 'phi -> ('chi -> ('phi & 'psi) | ('phi & 'chi));
  |PropCommutation, #left2| 'chi -> ('phi -> ('phi & 'psi) | ('phi & 'chi));.

  We can combine <ref #right2 /> and <ref #left2 /> to get

  |OrElim| ('psi | 'chi) -> ('phi -> ('phi & 'psi) | ('phi & 'chi));.

  From here, it's just a simple rearrangement to get the forward implication.

  |PropCommutation| 'phi -> (('psi | 'chi) -> ('phi & 'psi) | ('phi & 'chi));
  |PropImport| 'phi & ('psi | 'chi) -> ('phi & 'psi) | ('phi & 'chi);

  The backward implication is a little easier. From

  |OrRightIntro| 'psi -> 'psi | 'chi;,

  we can apply <ref ClassicalLogic.and /> to both sides of the implication to
  get

  |!sub, #right3| ('phi & 'psi) -> 'phi & ('psi | 'chi);.

  Similarly,

  |OrLeftIntro| 'chi -> 'psi | 'chi;
  |!sub, #left3| ('phi & 'chi) -> 'phi & ('psi | 'chi);.

  Finally, <ref #right3 /> and <ref #left3 /> can be combined to get the
  backward implication.

  |OrElim| ('phi & 'psi) | ('phi & 'chi) -> 'phi & ('psi | 'chi);

  Altogether, we get

  |EquivIntroInf| 'phi & ('psi | 'chi) <-> ('phi & 'psi) | ('phi & 'chi);.
}

# Propositional Resolution

\Theorem PropResolution: ClassicalLogic {
  name = "Propositional Resolution"

  tagline = {
    TODO: Tagline.
  }

  var phi: Prop
  var psi: Prop
  var chi: Prop

  assertion = ('phi | 'psi) & (!'phi | 'chi) -> 'psi | 'chi;
}

\Proof PropResolution: ClassicalLogic {
  |PropExplosion| !'phi -> ('phi -> 'psi | 'chi);
  |PropImport| (!'phi & 'phi) -> 'psi | 'chi;

  |AndLeftElim| (!'phi & 'psi) -> 'psi;
  |OrRightIntro| 'psi -> 'psi | 'chi;
  |Syllogism| (!'phi & 'psi) -> 'psi | 'chi;

  |OrElim| (!'phi & 'phi) | (!'phi & 'psi) -> 'psi | 'chi;

  |AndSymmetry| ('phi | 'psi) & !'phi -> !'phi & ('phi | 'psi);
  |AndDistribOr| !'phi & ('phi | 'psi) <-> (!'phi & 'phi) | (!'phi & 'psi);
  |EquivForwardInf| !'phi & ('phi | 'psi) -> (!'phi & 'phi) | (!'phi & 'psi);
  |Syllogism| ('phi | 'psi) & !'phi -> (!'phi & 'phi) | (!'phi & 'psi);

  |Syllogism| ('phi | 'psi) & !'phi -> 'psi | 'chi;

  |AndLeftElim| ('phi | 'psi) & 'chi -> 'chi;
  |OrLeftIntro| 'chi -> 'psi | 'chi;
  |Syllogism| ('phi | 'psi) & 'chi -> 'psi | 'chi;

  |OrElim| (('phi | 'psi) & !'phi) | (('phi | 'psi) & 'chi) -> 'psi | 'chi;
  |AndDistribOr|
    ('phi | 'psi) & (!'phi | 'chi)
      <-> (('phi | 'psi) & !'phi) | (('phi | 'psi) & 'chi);
  |EquivForwardInf|
    ('phi | 'psi) & (!'phi | 'chi)
      -> (('phi | 'psi) & !'phi) | (('phi | 'psi) & 'chi);
  |Syllogism| ('phi | 'psi) & (!'phi | 'chi) -> 'psi | 'chi;
}

# Automatically Proofs Using Propositional Calculus
